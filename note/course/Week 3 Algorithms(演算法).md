# Week 3 Algorithms(演算法)
---
### 演算法好壞分析
一個演算法的好壞可以用兩種複雜度來分析
1. 時間複雜度
2. 空間複雜度

只要其中一種複雜度效率不佳,都會大大影響執行的效能

複雜度較高的算法不一定就會執行比較久,EX:

線性搜索時間比二進位搜尋更久,但二進位搜尋只能用於排序後的資料,若先進行排序(O($n^2$))再搜尋,其效率便會比線性搜尋更低

##### 複雜度
演算法的優劣一般用兩種方法來判斷:
$O(n)$:最壞的情況下所需的步驟,O所表達的意思為"on the order of(按...排序)"
$\Omega(n)$:最好的情況下所需的步驟

其中n為資料個數,因為各語言、計算機、執行環境都不相同,所以分析演算法速度時我們以n為基底計算該演算法所需的步驟數來判斷其優劣

一般常見的演算法時間複雜度:
* O(n)
* O($n^2$)
* O($nlog^n$)
* O($log^n$)
* O(1)

在計算複雜度時,相近速度的演算法常被歸類在同一類
因為在x,y平面上其位置接近,所以習慣上會將它們作為同一速度來比較,常見的像是:
* O(n),O(n/2),O(n/3)....會被歸類為O(n)
* O($log_2^n$),O($log_3^n$)...會被歸類為O($log^n$)
### 演算法介紹
##### 氣泡排序
複雜度:O($n^2$)
(n-1)*(n-1)=$n^2-2n-1$
取最高次方項,所以複雜度為O($n^2$)

算法概念:
1. 遍歷陣列,若當前數字比下一個更大則交換位置
2. 到底時從開始位置+1的地方重新開始

偽代碼

	for i in a.length
	  for j =i+1 in a.length
		if a[i] > a[i+1]
		  兩數交換位置
	直到所有數右邊的數字皆大於自己		

##### 選擇排序
複雜度:O($n^2$)
n+(n-1)+(n-2)+...+1
n+(n+1)/2
$n^2+n/2$ 取最高次方為$n^2$

算法概念:
1. 遍歷陣列找到其中最小的數
2. 和最前面未排序的數交換位置
3. 從開始位置+1的地方重新開始

偽代碼

	for i in a.length
      for j =i+1 in a.length
	    找到子陣列最小的數
	    找到後若比i的數小則和i位置的數交換位置
	
##### 合併排序
複雜度:O($nlog^n$)

算法概念:
1. 將陣列分為左右兩半
2. 重複1.直到左右子陣列數量為1
3. 將子陣列排序,左邊小右邊大
4. 將排序好的兩子陣列按順序合併
5. 重複4.直到所有子陣列合併


### 字串比較
字串在C中代表的數據類行為數組

當用"=="來比較兩字串時便會失敗

使用`strcmp(str1,str2)`來比較兩字串,其返回結果同java的compareTo()方法
* 若返回0 則兩字串相等
* 若大於0 則str2字典順序小於str1
* 若小於0 則str2字典順序大於str1

### 遞迴
定義:函數呼叫自己執行

範例:列印出指定高度三角形
```c
#include <cs50.h>
#include <stdio.h>

void recursion(int i);

int main(void)
{
	int height = get_int("height: ");
	recursion(height);
}

void recursion(int i)
{
	if(i == 0)
	{
	  return;
	}
	recursion(i-1);

	for(int j = 0; j < i; j++)
	{
	  printf("%s", "#");
	}
	printf("\n");
}
```

### 物件
用`typedef struct`關鍵字建立物件,物件名稱寫在最尾端

建立一名稱為persion的物件,擁有name,phone兩屬性
```c
typedef struct
{
    string name;
    string phone;
}
persion;

int main(void)
{
 persion p;
 p.name = "Hi";
}
```
### 其他
##### 常數
`#define` 宣告後面的變數為一常數,其宣告位置通常在include後面
```c
#define MAX 9;
```